# coding: utf-8

"""
    iikoCloud API

    <h3>Description of common data formats:</h3><b>uuid</b> - string in UUID(universally unique identifier).<br/>Examples: <i>550e8400-e29b-41d4-a716-446655440000, b090de0b-8550-6e17-70b2-bbba152bcbd3</i><br/><br/><b>date-time</b> - date and time string in custom string format <b>yyyy-MM-dd HH:mm:ss.fff</b>.<br/>Examples: <i>2017-04-29 20:45:00.000, 2018-01-01 01:01:30.123</i>

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from iikocloud_client.models.transport_deliveries_response_order_conception import TransportDeliveriesResponseOrderConception
from iikocloud_client.models.transport_deliveries_response_order_discount_item import TransportDeliveriesResponseOrderDiscountItem
from iikocloud_client.models.transport_deliveries_response_order_employee import TransportDeliveriesResponseOrderEmployee
from iikocloud_client.models.transport_deliveries_response_order_external_data import TransportDeliveriesResponseOrderExternalData
from iikocloud_client.models.transport_deliveries_response_order_guests_info import TransportDeliveriesResponseOrderGuestsInfo
from iikocloud_client.models.transport_deliveries_response_order_loyalty_info import TransportDeliveriesResponseOrderLoyaltyInfo
from iikocloud_client.models.transport_deliveries_response_order_order_combo import TransportDeliveriesResponseOrderOrderCombo
from iikocloud_client.models.transport_deliveries_response_order_order_item import TransportDeliveriesResponseOrderOrderItem
from iikocloud_client.models.transport_deliveries_response_order_order_status import TransportDeliveriesResponseOrderOrderStatus
from iikocloud_client.models.transport_deliveries_response_order_order_type import TransportDeliveriesResponseOrderOrderType
from iikocloud_client.models.transport_deliveries_response_order_payment_item import TransportDeliveriesResponseOrderPaymentItem
from iikocloud_client.models.transport_deliveries_response_order_regular_customer import TransportDeliveriesResponseOrderRegularCustomer
from iikocloud_client.models.transport_deliveries_response_order_tips_payment_item import TransportDeliveriesResponseOrderTipsPaymentItem
from iikocloud_client.models.transport_table_orders_response_split_order_between_cash_registers import TransportTableOrdersResponseSplitOrderBetweenCashRegisters
from typing import Optional, Set
from typing_extensions import Self

class TransportTableOrdersResponseTableOrder(BaseModel):
    """
    Order.
    """ # noqa: E501
    table_ids: List[StrictStr] = Field(description="Table IDs.                Can be obtained by `/reserve/available_restaurant_sections` operation.", alias="tableIds")
    customer: Optional[TransportDeliveriesResponseOrderRegularCustomer] = Field(default=None, description="Guest.   > Allowed from version `7.5.2`.")
    phone: Optional[StrictStr] = Field(default=None, description="Guest phone.   > Allowed from version `7.5.2`.")
    status: TransportDeliveriesResponseOrderOrderStatus = Field(description="Order status.")
    when_created: Optional[StrictStr] = Field(default=None, description="Order creation date (terminal time zone).", alias="whenCreated")
    waiter: Optional[TransportDeliveriesResponseOrderEmployee] = Field(default=None, description="Order waiter.")
    tab_name: Optional[StrictStr] = Field(default=None, description="Tab name (only for fastfood terminals group in tab mode).", alias="tabName")
    split_order_between_cash_registers: Optional[TransportTableOrdersResponseSplitOrderBetweenCashRegisters] = Field(default=None, description="Need to split order between cash registers.  <remarks>  Not empty for orders in statuses New or Bill.  </remarks>", alias="splitOrderBetweenCashRegisters")
    menu_id: Optional[StrictStr] = Field(default=None, description="External menu ID.", alias="menuId")
    sum: Union[StrictFloat, StrictInt] = Field(description="Order amount (after discount or surcharge).")
    number: StrictInt = Field(description="Delivery No.")
    source_key: Optional[StrictStr] = Field(default=None, description="Delivery source.", alias="sourceKey")
    when_bill_printed: Optional[StrictStr] = Field(default=None, description="Invoice printing time (guest bill time).", alias="whenBillPrinted")
    when_closed: Optional[StrictStr] = Field(default=None, description="Delivery closing time (Local for delivery terminal).", alias="whenClosed")
    conception: Optional[TransportDeliveriesResponseOrderConception] = Field(default=None, description="Concept.")
    guests_info: Optional[TransportDeliveriesResponseOrderGuestsInfo] = Field(description="Information about order guests.", alias="guestsInfo")
    items: List[TransportDeliveriesResponseOrderOrderItem] = Field(description="Order items.")
    combos: Optional[List[TransportDeliveriesResponseOrderOrderCombo]] = Field(default=None, description="Combo.")
    payments: Optional[List[TransportDeliveriesResponseOrderPaymentItem]] = Field(default=None, description="Payments.")
    tips: Optional[List[TransportDeliveriesResponseOrderTipsPaymentItem]] = Field(default=None, description="Tips.")
    discounts: Optional[List[TransportDeliveriesResponseOrderDiscountItem]] = Field(default=None, description="Discounts.")
    order_type: Optional[TransportDeliveriesResponseOrderOrderType] = Field(description="Order type.", alias="orderType")
    terminal_group_id: StrictStr = Field(description="ID of the terminal group where the order is located.", alias="terminalGroupId")
    processed_payments_sum: Optional[Union[StrictFloat, StrictInt]] = Field(description="The amount of processed payments.  <remarks>  null - only for unsupported POS versions.  </remarks>   > Allowed from version `7.6.0`.", alias="processedPaymentsSum")
    loyalty_info: Optional[TransportDeliveriesResponseOrderLoyaltyInfo] = Field(default=None, description="Information about Loyalty app.  <remarks>  null - only for unsupported POS versions.  </remarks>", alias="loyaltyInfo")
    external_data: Optional[List[TransportDeliveriesResponseOrderExternalData]] = Field(default=None, description="Order external data.   > Allowed from version `8.0.6`.", alias="externalData")
    __properties: ClassVar[List[str]] = ["tableIds", "customer", "phone", "status", "whenCreated", "waiter", "tabName", "splitOrderBetweenCashRegisters", "menuId", "sum", "number", "sourceKey", "whenBillPrinted", "whenClosed", "conception", "guestsInfo", "items", "combos", "payments", "tips", "discounts", "orderType", "terminalGroupId", "processedPaymentsSum", "loyaltyInfo", "externalData"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TransportTableOrdersResponseTableOrder from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of customer
        if self.customer:
            _dict['customer'] = self.customer.to_dict()
        # override the default output from pydantic by calling `to_dict()` of waiter
        if self.waiter:
            _dict['waiter'] = self.waiter.to_dict()
        # override the default output from pydantic by calling `to_dict()` of conception
        if self.conception:
            _dict['conception'] = self.conception.to_dict()
        # override the default output from pydantic by calling `to_dict()` of guests_info
        if self.guests_info:
            _dict['guestsInfo'] = self.guests_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in items (list)
        _items = []
        if self.items:
            for _item_items in self.items:
                if _item_items:
                    _items.append(_item_items.to_dict())
            _dict['items'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in combos (list)
        _items = []
        if self.combos:
            for _item_combos in self.combos:
                if _item_combos:
                    _items.append(_item_combos.to_dict())
            _dict['combos'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in payments (list)
        _items = []
        if self.payments:
            for _item_payments in self.payments:
                if _item_payments:
                    _items.append(_item_payments.to_dict())
            _dict['payments'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in tips (list)
        _items = []
        if self.tips:
            for _item_tips in self.tips:
                if _item_tips:
                    _items.append(_item_tips.to_dict())
            _dict['tips'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in discounts (list)
        _items = []
        if self.discounts:
            for _item_discounts in self.discounts:
                if _item_discounts:
                    _items.append(_item_discounts.to_dict())
            _dict['discounts'] = _items
        # override the default output from pydantic by calling `to_dict()` of order_type
        if self.order_type:
            _dict['orderType'] = self.order_type.to_dict()
        # override the default output from pydantic by calling `to_dict()` of loyalty_info
        if self.loyalty_info:
            _dict['loyaltyInfo'] = self.loyalty_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in external_data (list)
        _items = []
        if self.external_data:
            for _item_external_data in self.external_data:
                if _item_external_data:
                    _items.append(_item_external_data.to_dict())
            _dict['externalData'] = _items
        # set to None if customer (nullable) is None
        # and model_fields_set contains the field
        if self.customer is None and "customer" in self.model_fields_set:
            _dict['customer'] = None

        # set to None if phone (nullable) is None
        # and model_fields_set contains the field
        if self.phone is None and "phone" in self.model_fields_set:
            _dict['phone'] = None

        # set to None if when_created (nullable) is None
        # and model_fields_set contains the field
        if self.when_created is None and "when_created" in self.model_fields_set:
            _dict['whenCreated'] = None

        # set to None if waiter (nullable) is None
        # and model_fields_set contains the field
        if self.waiter is None and "waiter" in self.model_fields_set:
            _dict['waiter'] = None

        # set to None if tab_name (nullable) is None
        # and model_fields_set contains the field
        if self.tab_name is None and "tab_name" in self.model_fields_set:
            _dict['tabName'] = None

        # set to None if split_order_between_cash_registers (nullable) is None
        # and model_fields_set contains the field
        if self.split_order_between_cash_registers is None and "split_order_between_cash_registers" in self.model_fields_set:
            _dict['splitOrderBetweenCashRegisters'] = None

        # set to None if menu_id (nullable) is None
        # and model_fields_set contains the field
        if self.menu_id is None and "menu_id" in self.model_fields_set:
            _dict['menuId'] = None

        # set to None if source_key (nullable) is None
        # and model_fields_set contains the field
        if self.source_key is None and "source_key" in self.model_fields_set:
            _dict['sourceKey'] = None

        # set to None if when_bill_printed (nullable) is None
        # and model_fields_set contains the field
        if self.when_bill_printed is None and "when_bill_printed" in self.model_fields_set:
            _dict['whenBillPrinted'] = None

        # set to None if when_closed (nullable) is None
        # and model_fields_set contains the field
        if self.when_closed is None and "when_closed" in self.model_fields_set:
            _dict['whenClosed'] = None

        # set to None if conception (nullable) is None
        # and model_fields_set contains the field
        if self.conception is None and "conception" in self.model_fields_set:
            _dict['conception'] = None

        # set to None if guests_info (nullable) is None
        # and model_fields_set contains the field
        if self.guests_info is None and "guests_info" in self.model_fields_set:
            _dict['guestsInfo'] = None

        # set to None if combos (nullable) is None
        # and model_fields_set contains the field
        if self.combos is None and "combos" in self.model_fields_set:
            _dict['combos'] = None

        # set to None if payments (nullable) is None
        # and model_fields_set contains the field
        if self.payments is None and "payments" in self.model_fields_set:
            _dict['payments'] = None

        # set to None if tips (nullable) is None
        # and model_fields_set contains the field
        if self.tips is None and "tips" in self.model_fields_set:
            _dict['tips'] = None

        # set to None if discounts (nullable) is None
        # and model_fields_set contains the field
        if self.discounts is None and "discounts" in self.model_fields_set:
            _dict['discounts'] = None

        # set to None if order_type (nullable) is None
        # and model_fields_set contains the field
        if self.order_type is None and "order_type" in self.model_fields_set:
            _dict['orderType'] = None

        # set to None if processed_payments_sum (nullable) is None
        # and model_fields_set contains the field
        if self.processed_payments_sum is None and "processed_payments_sum" in self.model_fields_set:
            _dict['processedPaymentsSum'] = None

        # set to None if loyalty_info (nullable) is None
        # and model_fields_set contains the field
        if self.loyalty_info is None and "loyalty_info" in self.model_fields_set:
            _dict['loyaltyInfo'] = None

        # set to None if external_data (nullable) is None
        # and model_fields_set contains the field
        if self.external_data is None and "external_data" in self.model_fields_set:
            _dict['externalData'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TransportTableOrdersResponseTableOrder from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "tableIds": obj.get("tableIds"),
            "customer": TransportDeliveriesResponseOrderRegularCustomer.from_dict(obj["customer"]) if obj.get("customer") is not None else None,
            "phone": obj.get("phone"),
            "status": obj.get("status"),
            "whenCreated": obj.get("whenCreated"),
            "waiter": TransportDeliveriesResponseOrderEmployee.from_dict(obj["waiter"]) if obj.get("waiter") is not None else None,
            "tabName": obj.get("tabName"),
            "splitOrderBetweenCashRegisters": obj.get("splitOrderBetweenCashRegisters"),
            "menuId": obj.get("menuId"),
            "sum": obj.get("sum"),
            "number": obj.get("number"),
            "sourceKey": obj.get("sourceKey"),
            "whenBillPrinted": obj.get("whenBillPrinted"),
            "whenClosed": obj.get("whenClosed"),
            "conception": TransportDeliveriesResponseOrderConception.from_dict(obj["conception"]) if obj.get("conception") is not None else None,
            "guestsInfo": TransportDeliveriesResponseOrderGuestsInfo.from_dict(obj["guestsInfo"]) if obj.get("guestsInfo") is not None else None,
            "items": [TransportDeliveriesResponseOrderOrderItem.from_dict(_item) for _item in obj["items"]] if obj.get("items") is not None else None,
            "combos": [TransportDeliveriesResponseOrderOrderCombo.from_dict(_item) for _item in obj["combos"]] if obj.get("combos") is not None else None,
            "payments": [TransportDeliveriesResponseOrderPaymentItem.from_dict(_item) for _item in obj["payments"]] if obj.get("payments") is not None else None,
            "tips": [TransportDeliveriesResponseOrderTipsPaymentItem.from_dict(_item) for _item in obj["tips"]] if obj.get("tips") is not None else None,
            "discounts": [TransportDeliveriesResponseOrderDiscountItem.from_dict(_item) for _item in obj["discounts"]] if obj.get("discounts") is not None else None,
            "orderType": TransportDeliveriesResponseOrderOrderType.from_dict(obj["orderType"]) if obj.get("orderType") is not None else None,
            "terminalGroupId": obj.get("terminalGroupId"),
            "processedPaymentsSum": obj.get("processedPaymentsSum"),
            "loyaltyInfo": TransportDeliveriesResponseOrderLoyaltyInfo.from_dict(obj["loyaltyInfo"]) if obj.get("loyaltyInfo") is not None else None,
            "externalData": [TransportDeliveriesResponseOrderExternalData.from_dict(_item) for _item in obj["externalData"]] if obj.get("externalData") is not None else None
        })
        return _obj


