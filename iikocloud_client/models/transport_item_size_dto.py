# coding: utf-8

"""
    iikoCloud API

    <h3>Description of common data formats:</h3><b>uuid</b> - string in UUID(universally unique identifier).<br/>Examples: <i>550e8400-e29b-41d4-a716-446655440000, b090de0b-8550-6e17-70b2-bbba152bcbd3</i><br/><br/><b>date-time</b> - date and time string in custom string format <b>yyyy-MM-dd HH:mm:ss.fff</b>.<br/>Examples: <i>2017-04-29 20:45:00.000, 2018-01-01 01:01:30.123</i>

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from iikocloud_client.models.transport_modifier_group_dto import TransportModifierGroupDto
from iikocloud_client.models.transport_price_dto import TransportPriceDto
from typing import Optional, Set
from typing_extensions import Self

class TransportItemSizeDto(BaseModel):
    """
    TransportItemSizeDto
    """ # noqa: E501
    prices: Optional[List[TransportPriceDto]] = None
    item_modifier_groups: Optional[List[TransportModifierGroupDto]] = Field(default=None, alias="itemModifierGroups")
    sku: Optional[StrictStr] = Field(default=None, description="Unique size code, consists of the product code and the name of the size, if the product has one size, then the size code will be equal to the product code")
    size_code: Optional[StrictStr] = Field(default=None, alias="sizeCode")
    size_name: Optional[StrictStr] = Field(default=None, description="Name of the product size, the name can be empty if there is only one size in the list", alias="sizeName")
    is_default: Optional[StrictBool] = Field(default=None, description="Whether it is a default size of the product. If the product has one size, then the parameter will be true, if the product has several sizes, none of them can be default.", alias="isDefault")
    portion_weight_grams: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Size's weight", alias="portionWeightGrams")
    size_id: Optional[StrictStr] = Field(default=None, description="ID size, can be empty if the default size is selected and it is the only size in the list", alias="sizeId")
    nutrition_per_hundred_grams: Optional[Dict[str, Any]] = Field(default=None, alias="nutritionPerHundredGrams")
    button_image_url: Optional[StrictStr] = Field(default=None, description="links to images", alias="buttonImageUrl")
    button_image_cropped_url: Optional[List[StrictStr]] = Field(default=None, alias="buttonImageCroppedUrl")
    __properties: ClassVar[List[str]] = ["prices", "itemModifierGroups", "sku", "sizeCode", "sizeName", "isDefault", "portionWeightGrams", "sizeId", "nutritionPerHundredGrams", "buttonImageUrl", "buttonImageCroppedUrl"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TransportItemSizeDto from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in prices (list)
        _items = []
        if self.prices:
            for _item_prices in self.prices:
                if _item_prices:
                    _items.append(_item_prices.to_dict())
            _dict['prices'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in item_modifier_groups (list)
        _items = []
        if self.item_modifier_groups:
            for _item_item_modifier_groups in self.item_modifier_groups:
                if _item_item_modifier_groups:
                    _items.append(_item_item_modifier_groups.to_dict())
            _dict['itemModifierGroups'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TransportItemSizeDto from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "prices": [TransportPriceDto.from_dict(_item) for _item in obj["prices"]] if obj.get("prices") is not None else None,
            "itemModifierGroups": [TransportModifierGroupDto.from_dict(_item) for _item in obj["itemModifierGroups"]] if obj.get("itemModifierGroups") is not None else None,
            "sku": obj.get("sku"),
            "sizeCode": obj.get("sizeCode"),
            "sizeName": obj.get("sizeName"),
            "isDefault": obj.get("isDefault"),
            "portionWeightGrams": obj.get("portionWeightGrams"),
            "sizeId": obj.get("sizeId"),
            "nutritionPerHundredGrams": obj.get("nutritionPerHundredGrams"),
            "buttonImageUrl": obj.get("buttonImageUrl"),
            "buttonImageCroppedUrl": obj.get("buttonImageCroppedUrl")
        })
        return _obj


